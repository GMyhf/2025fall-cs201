#  Problems in cs101.openjudge.cn

*Updated 2025-08-31 22:28 GMT+8*
 *Compiled by Hongfei Yan (2025 Fall)*



> Logs:
>
> 鉴于每学期都有同学偏好C++编程，本学期除维护Python题解外，也开始提供C++题解支持。



# Easy

## E01003: Hangover

math, http://cs101.openjudge.cn/pctbook/E01003/

How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We're assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1/2 `+` 1/3 `=` 5/6 card lengths. In general you can make *n* cards overhang by 1/2 `+`1/3 `+` 1/4 `+` ... `+` 1/(*n* `+` 1) card lengths, where the top card overhangs the second by 1/2, the second overhangs tha third by 1/3, the third overhangs the fourth by 1/4, etc., and the bottom card overhangs the table by 1/(*n* `+` 1). This is illustrated in the figure below.

![img](http://media.openjudge.cn/images/1003/hangover.jpg)

**输入**

The input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. Each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits.

**输出**

For each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. Use the exact output format shown in the examples.

样例输入

```
1.00
3.71
0.04
5.19
0.00
```

样例输出

```
3 card(s)
61 card(s)
1 card(s)
273 card(s)
```

来源

Mid-Central USA 2001



这个问题要求我们找到最少的卡片数，使得它们的叠加悬空距离至少为给定的 `c` 值。

**思路分析**：

每增加一张卡片，叠加的总过hang值是一个调和数列的部分和：

- 第 1 张卡片过hang `1/2` 长度。
- 第 2 张卡片过hang `1/3` 长度。
- 第 3 张卡片过hang `1/4` 长度。
- 依此类推。

所以，当卡片数量为 `n` 时，叠加的总过hang值为：

`Hn=1/2+1/3+1/4+⋯+1/n+1`

我们需要找到最小的 `n`，使得：

`Hn ≥ c`

这就变成了一个计算调和数列部分和的问题。



```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double c;
    while (cin >> c) {
        if (c == 0.00) {
            break;
        }
        
        double overhang = 0.0;
        int cards = 0;

        // 增加卡片，直到总过hang值大于等于c
        while (overhang < c) {
            cards++;
            overhang += 1.0 / (cards + 1);  // 每张卡片的过hang值
        }

        // 输出结果，卡片数量
        cout << cards << " card(s)" << endl;
    }

    return 0;
}
```

> `<iomanip>` 是 C++ 标准库中的一个头文件，主要用于处理输入输出的格式化。它提供了一些控制输入输出格式的工具，例如设置数字的精度、宽度、对齐方式等。
>
> **常见的 `iomanip` 功能：**
>
> 1. **设置输出的精度（`setprecision`）**：
>    `setprecision` 用来指定浮点数输出的精度，即输出小数点后保留的位数。
>
>    ```cpp
>    #include <iostream>
>    #include <iomanip>
>    using namespace std;
>                
>    int main() {
>        double pi = 3.14159265358979;
>        cout << setprecision(5) << pi << endl; // 输出 3.1416
>        return 0;
>    }
>    ```
>
>    这个例子中，`setprecision(5)` 设置了输出精度为 5 位数字。
>
> 2. **固定小数点输出（`fixed`）**：
>    默认情况下，C++ 会根据数字的大小自动决定浮点数是以科学计数法（例如 `1.23e+4`）还是普通的十进制形式输出。如果你希望强制浮点数以小数点形式输出，可以使用 `fixed`。
>
>    ```cpp
>    #include <iostream>
>    #include <iomanip>
>    using namespace std;
>                
>    int main() {
>        double pi = 3.14159265358979;
>        cout << fixed << setprecision(4) << pi << endl; // 输出 3.1416
>        return 0;
>    }
>    ```
>
>    这段代码会强制 `pi` 以小数点形式输出，保留 4 位小数。
>
> 3. **设置输出宽度（`setw`）**：
>    `setw` 用来设置输出字段的宽度。如果输出的数据宽度小于 `setw` 设置的宽度，C++ 会自动填充空格来补齐。
>
>    ```cpp
>    #include <iostream>
>    #include <iomanip>
>    using namespace std;
>                
>    int main() {
>        int x = 42;
>        cout << setw(5) << x << endl;  // 输出 "   42"（宽度为5）
>        return 0;
>    }
>    ```
>
> 4. **对齐设置（`left`, `right`, `internal`）**：
>    通过 `left`, `right`, 和 `internal` 来控制输出对齐方式：
>
>    - `left`：左对齐
>    - `right`：右对齐（默认）
>    - `internal`：将符号位（正负号）对齐到输出字段的内部（即数字右侧，符号前）
>
>    ```cpp
>    #include <iostream>
>    #include <iomanip>
>    using namespace std;
>                
>    int main() {
>        cout << left << setw(10) << "Hello" << endl;  // 输出 "Hello     "
>        cout << right << setw(10) << "Hello" << endl; // 输出 "     Hello"
>        return 0;
>    }
>    ```
>
> 5. **填充字符（`setfill`）**：
>    `setfill` 用于设置输出时填充字符。如果字段宽度不足，输出会使用该字符来填充。
>
>    ```cpp
>    #include <iostream>
>    #include <iomanip>
>    using namespace std;
>                
>    int main() {
>        cout << setfill('*') << setw(10) << 42 << endl;  // 输出 "******42"
>        return 0;
>    }
>    ```
>
> **常见的 `iomanip` 常量：**
>
> - **`fixed`**：强制以小数点形式输出浮点数。
> - **`scientific`**：强制以科学计数法输出浮点数。
> - **`setprecision(n)`**：设置浮点数输出的精度，保留 n 位小数。
> - **`setw(n)`**：设置输出的宽度，输出内容小于 n 时会自动填充空格。
> - **`setfill(ch)`**：设置填充字符，输出内容小于指定宽度时会用该字符填充。
>
> **示例代码：**
>
> ```cpp
> #include <iostream>
> #include <iomanip>
> using namespace std;
> 
> int main() {
>     double pi = 3.14159265358979;
>     int number = 42;
> 
>     // 设置精度为 3 位小数
>     cout << fixed << setprecision(3) << pi << endl;  // 输出 3.142
>     
>     // 设置输出宽度为 10，使用填充字符 '*'
>     cout << setfill('*') << setw(10) << number << endl;  // 输出 "******42"
>     
>     // 设置对齐方式为右对齐
>     cout << right << setw(10) << number << endl;  // 输出 "       42"
> 
>     return 0;
> }
> ```
>
> **总结：**
>
> `<iomanip>` 使得你可以灵活地控制 C++ 输出格式，常用的有设置浮点数精度、输出宽度、对齐方式、填充字符等功能。



## E02676: 整数的个数

math, http://cs101.openjudge.cn/pctbook/E02676/

给定k（1< k < 100）个正整数，其中每个数都是大于等于1，小于等于10的数。写程序计算给定的k个正整数中，1，5和10出现的次数。

**输入**

输入有两行：第一行包含一个正整数k，第二行包含k个正整数，每两个正整数用一个空格分开。

**输出**

输出有三行，第一行为1出现的次数，，第二行为5出现的次数，第三行为10出现的次数。

样例输入

```
5
1 5 8 10 5 
```

样例输出

```
1
2
1
```

来源

计算概论05－模拟考试1



```c++
#include <iostream>
using namespace std;

int main() {
    int k;
    cin >> k;
    int cnt1 = 0, cnt5 = 0, cnt10 = 0;
    for (int i = 0; i < k; i++) {
        int x;
        cin >> x;
        if (x == 1) cnt1++;
        else if (x == 5) cnt5++;
        else if (x == 10) cnt10++;
    }
    cout << cnt1 << endl;
    cout << cnt5 << endl;
    cout << cnt10 << endl;
    return 0;
}

```



```c++
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    int k;
    cin >> k;
    cin.ignore();   // 忽略掉换行符

    string line;
    getline(cin, line);   // 读入整行数字

    stringstream ss(line);
    int x, cnt1 = 0, cnt5 = 0, cnt10 = 0;

    while (ss >> x) {   // 按空格自动分割。>> 操作符自动忽略多余的空格、换行符
        if (x == 1) cnt1++;
        else if (x == 5) cnt5++;
        else if (x == 10) cnt10++;
    }

    cout << cnt1 << "\n" << cnt5 << "\n" << cnt10 << endl;
    return 0;
}

```



【鲍雷栋，2021年秋，物理学院】

由于 Python 对整型高精度的支持，对 C++ 及其他语言使用者来说学习 Python 基础语法是有必要的。应当说，学习 Python 中的一道坎是接受它的输入和输出方式，在习惯了其他语言输入输出方式后再学 Python 的直接一行输入一行输出的方式有种“难以理解”的感觉，仿佛无形之中增添了麻烦。

但在一些输入形式上，Python 自带的函数却提供了便捷，例如split。为了让 C++ 选手们减少不必要的痛苦，将 C++ 中实现 split 的代码放在下面，实现利用了 stringstream 和 vector，如果需要读取 int 或 double，利用自带的 stoi 或 stod 转换即可。

```c++
#include <iostream>
#include <vector>
#include <sstream>
using namespace std;

// 模拟 Python 的 split 函数
vector<string> split(string str, char sp) {
    istringstream iss(str);
    vector<string> res;
    string subs;
    while (getline(iss, subs, sp)) {
        if (!subs.empty()) res.push_back(subs);
    }
    return res;
}

int main() {
    int k;
    cin >> k;          // 读入 k
    cin.ignore();      // 忽略掉换行符，不然 getline 会读到空行

    string line;
    getline(cin, line);   // 一次性读入整行数字

    vector<string> nums = split(line, ' ');  // 按空格分割
    int cnt1 = 0, cnt5 = 0, cnt10 = 0;

    for (string s : nums) {
        int x = stoi(s);   // 转换为整数
        if (x == 1) cnt1++;
        else if (x == 5) cnt5++;
        else if (x == 10) cnt10++;
    }

    cout << cnt1 << "\n" << cnt5 << "\n" << cnt10 << endl;
    return 0;
}

```



## E02733: 判断闰年

math, http://cs101.openjudge.cn/pctbook/E02733

判断某年是否是闰年。

**输入**

输入只有一行，包含一个整数a(0 < a < 3000)

**输出**

一行，如果公元a年是闰年输出Y，否则输出N

样例输入

```
2006
```

样例输出

```
N
```

提示

公历纪年法中，能被4整除的大多是闰年，但能被100整除而不能被400整除的年份不是闰年， 能被3200整除的也不是闰年，如1900年是平年，2000年是闰年，3200年不是闰年。



C语言在语法层面上基本是C++的子集，因此许多用C语言编写的程序也能直接使用C++编译器进行编译。例如，下面这段代码虽然是典型的C风格写法，但同样可以用C++编译器成功编译并运行

```c++
#include <cstdlib>
#include <cstdio>

int main()
{
    int a;
    scanf("%d", &a);

    if (a % 4 == 0)
    {
        if (a % 100 == 0 && a % 400 != 0)
            printf("N");
        else
            printf("Y");
    }
    else
        printf("N");
}
```



## E02750: 鸡兔同笼

math, http://cs101.openjudge.cn/pctbook/E02750/

一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。

**输入**

一行，一个正整数a (a < 32768)。

**输出**

一行，包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开。
如果没有满足要求的答案，则输出两个0，中间用一个空格分开。

样例输入

```
20
```

样例输出

```
5 10
```



```c++
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    int b = n / 2; // 最多动物数
    if (n % 4 == 2) {
        int a = (n + 2) / 4; // 最少动物数
        cout << a << " " << b << endl;
    } else if (n % 4 == 0) {
        int a = n / 4; // 最少动物数
        cout << a << " " << b << endl;
    } else {
        cout << "0 0" << endl; // 无解
    }

    return 0;
}

```



#### E04067: 回文数字（Palindrome Number）

two pointers, queue, http://cs101.openjudge.cn/pctbook/E04067/

给出一系列非负整数，判断是否是一个回文数。回文数指的是正着写和倒着写相等的数。

**输入**

若干行，每行是一个非负整数（不超过99999999）

**输出**

对每行输入，如果其是一个回文数，输出YES。否则输出NO。

样例输入

```
11
123
0
14277241
67945497
```

样例输出

```
YES
NO
YES
YES
NO
```



这是经典的**回文串判定**问题。常见思路有：

1. **双指针法**
   从字符串首尾同时向中间比较。
2. **队列（deque）法**
   使用双端队列，从两端依次弹出比较。
3. **直接翻转字符串**
   判断 `s == reversed(s)`。

同时，本题需要处理**不定行输入**，在 C++ 中常用 `while (cin >> s)` 来逐行读取。



双指针法

```c++
#include <iostream>
#include <string>
using namespace std;

bool isPalindrome(const string &s) {
    int front = 0, back = s.size() - 1;
    while (front < back) {
        if (s[front] != s[back]) return false;
        front++;
        back--;
    }
    return true;
}

int main() {
    string s;
    while (cin >> s) {  // 处理不定行输入
        cout << (isPalindrome(s) ? "YES" : "NO") << endl;
    }
    return 0;
}

```



使用 deque 模拟双端队列

```c++
#include <iostream>
#include <string>
#include <deque>
using namespace std;

string isPalindrome(const string &s) {
    deque<char> dq(s.begin(), s.end());
    while (dq.size() > 1) {
        if (dq.front() != dq.back()) return "NO";
        dq.pop_front();
        dq.pop_back();
    }
    return "YES";
}

int main() {
    string s;
    while (cin >> s) {
        cout << isPalindrome(s) << endl;
    }
    return 0;
}

```



直接反转字符串

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    string s;
    while (cin >> s) {
        string rev = s;
        reverse(rev.begin(), rev.end());
        cout << (s == rev ? "YES" : "NO") << endl;
    }
    return 0;
}

```



## E07618: 病人排队

sorting, http://cs101.openjudge.cn/pctbook/E07618/

病人登记看病，编写一个程序，将登记的病人按照以下原则排出看病的先后顺序：

1. 老年人（年龄 >= 60岁）比非老年人优先看病。
2. 老年人按年龄从大到小的顺序看病，年龄相同的按登记的先后顺序排序。
3. 非老年人按登记的先后顺序看病。



**输入**

第1行，输入一个小于100的正整数，表示病人的个数；
后面按照病人登记的先后顺序，每行输入一个病人的信息，包括：一个长度小于10的字符串表示病人的ID（每个病人的ID各不相同且只含数字和字母），一个整数表示病人的年龄，中间用单个空格隔开。

**输出**

按排好的看病顺序输出病人的ID，每行一个。

样例输入

```
5
021075 40
004003 15
010158 67
021033 75
102012 30
```

样例输出

```
021033
010158
021075
004003
102012
```

来源

习题(14-6)



**使用`stable_sort`**：为了确保老年人按登记顺序排，如果年龄相同，`stable_sort` 可以保证相同年龄的老年人保持输入时的顺序。sort不稳定，会WA。

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

struct ren {
    string id;
    int a;
    ren(string i, int A) : id(i), a(A){}
    ren() : id(""), a(0){}
};

ren l[105];
ren r[105];

bool cmp(ren a, ren b) {
    return a.a > b.a;
}

int main() {
    int n;
    cin >> n;
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        string s;
        int a;
        cin >> s >> a;
        if (a >= 60) {
            cnt++;
            l[cnt] = ren(s, a);
        } else {
            r[i - cnt] = ren(s, a);
        }
    }
    stable_sort(l + 1, l + cnt + 1, cmp);
    for (int i = 1; i <= cnt; i++) {
        cout << l[i].id << endl;
    }
    for (int i = 1; i <= n - cnt; i++) {
        cout << r[i].id << endl;
    }
    return 0;
}

```





# Medium

## M01321: 棋盘问题

backtracking, http://cs101.openjudge.cn/pctbook/M01321

在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。

**输入**

输入含有多组测试数据。
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 , k <= n
当为-1 -1时表示输入结束。
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。

**输出**

对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。

样例输入

```
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
```

样例输出

```
2
1
```

来源

蔡错@pku



这个问题要求我们在一个不规则的棋盘上摆放棋子，且任何两个棋子都不能放在同一行或同一列。我们需要找出所有符合条件的摆放方案数。

**思路分析：**

1. **棋盘的表示：**
   棋盘是一个`n*n`的矩阵，每个位置上可能是`#`（可以放棋子）或者`.`（不能放棋子）。
2. **摆放棋子的要求：**
   - 不同的棋子不能在同一行或同一列。
   - `k`个棋子必须放置在`#`的位置上。
3. **求解方法：**
   这类似于**n皇后问题**的变种，可以使用**回溯法**来搜索所有可行的摆放方案。
4. **回溯法：**
   - 通过回溯的方法尝试在棋盘上放置`k`个棋子。
   - 需要记录已被放置棋子的行和列，避免放在同一行或同一列。
   - 只考虑可以放棋子的格子，即`#`的位置。
5. **输入与输出：**
   - 输入中有多组测试数据，直到输入为`-1 -1`时结束。
   - 对每组数据输出可行的摆放方案数。



```cpp
#include <iostream>
#include <vector>

using namespace std;

// 回溯函数
void placePieces(int n, int k, int row, vector<string>& board, vector<int>& cols, int& count) {
    // 如果已经放置了k个棋子，计数加一
    if (k == 0) {
        count++;
        return;
    }
    
    // 从当前行row开始尝试
    for (int i = row; i < n; i++) {
        // 遍历该行所有列
        for (int j = 0; j < n; j++) {
            // 如果当前位置是可放棋子的地方，并且没有放置在该列，且该行还没被用过
            if (board[i][j] == '#' && !cols[j]) {
                // 放置棋子，标记该行和该列
                cols[j] = 1;
                placePieces(n, k - 1, i + 1, board, cols, count);
                // 回溯，撤销棋子的放置
                cols[j] = 0;
            }
        }
    }
}

int main() {
    int n, k;
    
    while (cin >> n >> k, n != -1 && k != -1) {
        vector<string> board(n);
        for (int i = 0; i < n; i++) {
            cin >> board[i];
        }
        
        vector<int> cols(n, 0);  // 用来记录列的状态，0表示该列没有放棋子，1表示放了
        int count = 0;
        
        placePieces(n, k, 0, board, cols, count);
        
        cout << count << endl;
    }
    
    return 0;
}
```

代码解释：

1. **`placePieces`函数**：
   - 这是一个回溯函数，用来递归地在棋盘上放置`k`个棋子。
   - 参数：
     - `n`：棋盘的大小。
     - `k`：当前需要放置的棋子数目。
     - `row`：当前正在处理的行。
     - `board`：棋盘的形状，记录每个位置是否可放棋子。
     - `cols`：一个数组，用来标记哪些列已经被占用。
     - `count`：用来记录当前的方案数。
   - 回溯的核心是：在一个行内，尝试将棋子放在每个`#`的位置上，放置棋子后递归处理下一个棋子，放置后回溯撤销该放置，继续寻找下一个位置。
2. **`main`函数**：
   - 读取输入，处理每一组测试数据。
   - 对于每组数据，调用`placePieces`函数来计算所有可能的摆放方案数。

**时间复杂度：**

- 由于最多有`n`行，每行最多有`n`个格子需要判断，递归过程中最多会遍历所有可能的放置方式。
- 回溯的时间复杂度大致为`O(n^k)`，其中`k`是要摆放的棋子数。





## M02786: Pell数列

dp, http://cs101.openjudge.cn/pctbook/M02786/

Pell数列a1, a2, a3, ...的定义是这样的，a1 = 1, a2 = 2, ... , an = 2 * an − 1 + an - 2 (n > 2)。
给出一个正整数k，要求Pell数列的第k项模上32767是多少。

**输入**

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数k (1 ≤ k < 1000000)。

**输出**

n行，每行输出对应一个输入。输出应是一个非负整数。

样例输入

```
2
1
8
```

样例输出

```
1
408
```





可以用**尾递归**优化。

将递归函数改写成尾递归形式的关键在于确保递归调用是函数的最后一个动作，并且所有必要的状态信息都通过参数传递。对于 `pell` 函数，可以使用两个辅助参数来保存前两个佩尔数的值，从而实现尾递归。

尾递归优化：C++ 编译器通常会优化尾递归，因此这种实现方式在处理大范围的 n 时通常不会遇到栈溢出的问题。Python 的官方解释器 CPython 并不支持尾递归优化。

```c++
#include <iostream>
#include <vector>

const int MOD = 32767;

// 尾递归函数
int pell_tail(int n, int a = 1, int b = 2) {
    if (n == 1) {
        return a;
    }
    if (n == 2) {
        return b;
    }
    return pell_tail(n - 1, b, (2 * b + a) % MOD);
}

int main() {
    const int MAX_N = 1000000;
    std::vector<int> dp(MAX_N, 0);

    int n;
    std::cin >> n;

    for (int i = 0; i < n; ++i) {
        int k;
        std::cin >> k;

        if (dp[k] != 0) {
            std::cout << dp[k] << std::endl;
        } else {
            dp[k] = pell_tail(k) % MOD;
            std::cout << dp[k] << std::endl;
        }
    }

    return 0;
}
```



## M04123: 马走日

backtracking, http://cs101.openjudge.cn/pctbook/M04123

马在中国象棋以日字形规则移动。

请编写一段程序，给定n*m大小的棋盘，以及马的初始位置(x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。

输入

第一行为整数T(T < 10)，表示测试数据组数。
每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标n,m,x,y。(0<=x<=n-1,0<=y<=m-1, m < 10, n < 10)

输出

每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，0为无法遍历一次。

样例输入

```
1
5 4 0 0
```

样例输出

```
32
```



这个问题可以使用回溯算法来解决。需要模拟马的移动路径，并在每一步检查是否能访问到棋盘上的所有点。

**思路**：

1. 马的移动遵循“日”字形规则，可以向8个方向移动：上下左右及斜对角。
2. 使用回溯法遍历棋盘上的每一个点。每当访问一个新的点，就将其标记为已访问，且递归尝试访问下一个点。
3. 如果能够成功访问所有棋盘点（即移动的步数等于棋盘的大小），则记录为一个有效路径。
4. 避免重复访问，使用一个二维数组来标记每个点是否已访问过。

**步骤**：

1. 先初始化棋盘的大小和起始位置。
2. 使用回溯递归进行搜索。
3. 检查每一个方向的移动是否合法，并在合法时进行递归调用。
4. 当递归到达棋盘的所有点时，计数有效路径。



```cpp
#include <iostream>
#include <vector>

using namespace std;

const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};  // 马的横向移动
const int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};  // 马的纵向移动

// 回溯法计算遍历路径的数量
void dfs(int x, int y, int n, int m, int visited_count, vector<vector<bool>>& visited, int& result) {
    // 如果已经遍历了所有格子
    if (visited_count == n * m) {
        result++;
        return;
    }

    // 尝试所有8个方向
    for (int i = 0; i < 8; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        
        // 如果新位置合法并且没有被访问过
        if (nx >= 0 && ny >= 0 && nx < n && ny < m && !visited[nx][ny]) {
            visited[nx][ny] = true;
            dfs(nx, ny, n, m, visited_count + 1, visited, result);
            visited[nx][ny] = false;  // 回溯
        }
    }
}

int main() {
    int T;
    cin >> T;  // 输入测试数据组数
    
    while (T--) {
        int n, m, x, y;
        cin >> n >> m >> x >> y;  // 输入棋盘大小和起始位置

        // 访问标记数组，初始化为false
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        int result = 0;

        // 从起始位置(x, y)开始，标记为已访问
        visited[x][y] = true;
        dfs(x, y, n, m, 1, visited, result);

        // 输出结果
        cout << result << endl;
    }
    
    return 0;
}
```

代码解释：

1. **dx 和 dy 数组**：定义了马可以向8个方向移动的偏移量。
2. **dfs 函数**：使用递归进行回溯。参数包括当前坐标 `(x, y)`，棋盘大小 `n, m`，已访问的点数 `visited_count`，标记访问状态的 `visited` 数组，以及存储结果的 `result`。
3. **回溯过程**：每次尝试马的8个可能的移动，若合法且未访问过，就递归调用。
4. **主函数**：首先读取测试数据组数 `T`，然后每组数据执行一次 `dfs`，最终输出结果。

复杂度：

- 在最坏的情况下，每个位置都要遍历一次，且对于每个位置尝试8个方向的移动。最坏时间复杂度为 O(8^N)（其中 N 为棋盘的格数）。但由于棋盘大小限制，最大为 9x9，实际运行时会比这个上限快得多。





## M08210: 河中跳房子

binary search, greedy, http://cs101.openjudge.cn/pctbook/M08210

每年奶牛们都要举办各种特殊版本的跳房子比赛，包括在河里从一个岩石跳到另一个岩石。这项激动人心的活动在一条长长的笔直河道中进行，在起点和离起点L远 (1 ≤ *L*≤ 1,000,000,000) 的终点处均有一个岩石。在起点和终点之间，有*N* (0 ≤ *N* ≤ 50,000) 个岩石，每个岩石与起点的距离分别为*Di (0 < \*Di\* < \*L*)。*

在比赛过程中，奶牛轮流从起点出发，尝试到达终点，每一步只能从一个岩石跳到另一个岩石。当然，实力不济的奶牛是没有办法完成目标的。

农夫约翰为他的奶牛们感到自豪并且年年都观看了这项比赛。但随着时间的推移，看着其他农夫的胆小奶牛们在相距很近的岩石之间缓慢前行，他感到非常厌烦。他计划移走一些岩石，使得从起点到终点的过程中，最短的跳跃距离最长。他可以移走除起点和终点外的至多*M* (0 ≤ *M* ≤ *N*) 个岩石。

请帮助约翰确定移走这些岩石后，最长可能的最短跳跃距离是多少？



**输入**

第一行包含三个整数L, N, M，相邻两个整数之间用单个空格隔开。
接下来N行，每行一个整数，表示每个岩石与起点的距离。岩石按与起点距离从近到远给出，且不会有两个岩石出现在同一个位置。

**输出**

一个整数，最长可能的最短跳跃距离。

样例输入

```
25 5 2
2
11
14
17
21
```

样例输出

```
4
```

提示

在移除位于2和14的两个岩石之后，最短跳跃距离为4（从17到21或从21到25）。





```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool canAchieve(const vector<int>& rocks, int L, int M, int minDist) {
    int removed = 0;  // 记录移除的岩石数量
    int prev = 0;     // 记录上一个岩石的位置（起点）

    for (int i = 1; i < rocks.size(); i++) {
        if (rocks[i] - rocks[prev] < minDist) {
            removed++;  // 如果当前岩石与上一个岩石的距离小于 minDist，则移除当前岩石
            if (removed > M) {
                return false;  // 超过可移除的岩石数量，返回 false
            }
        } else {
            prev = i;  // 更新上一个岩石的位置
        }
    }
    return true;  // 可以满足要求
}

int maxMinJump(int L, int N, int M, const vector<int>& rocks) {
    // 先将岩石位置排序，并加入起点和终点
    vector<int> allRocks = {0};
    allRocks.insert(allRocks.end(), rocks.begin(), rocks.end());
    allRocks.push_back(L);

    int left = 0, right = L + 1;  // 二分查找的范围是 [0, L+1)

    int ans = -1;
    while (left < right) {
        int mid = (left + right) / 2;  // 取中间偏右的值
        if (canAchieve(allRocks, L, M, mid)) {
            ans = mid;    // 如果 mid 可行，记录答案并尝试更大的值
            left = mid + 1;
        } else {
            right = mid;  // 否则尝试更小的值
        }
    }
    return ans;
}

int main() {
    int L, N, M;
    cin >> L >> N >> M;

    vector<int> rocks(N);
    for (int i = 0; i < N; i++) {
        cin >> rocks[i];
    }

    // 计算并输出答案
    cout << maxMinJump(L, N, M, rocks) << endl;

    return 0;
}
```



> **`canAchieve` 函数**：
>
> - 这个函数的作用是判断是否可以通过移除至多 `M` 个岩石，确保最短跳跃距离不小于 `minDist`。
> - 从起点开始，依次检查岩石的位置。如果当前岩石与上一个岩石之间的距离小于 `minDist`，则认为这个岩石需要被移除。如果移除的岩石数超过了 `M`，则返回 `false`。否则，更新上一个岩石的位置。
>
> **`maxMinJump` 函数**：
>
> - 该函数使用二分查找来查找最大可能的最小跳跃距离。二分查找的范围是 `[0, L+1)`，每次计算中值 `mid`，并使用 `canAchieve` 判断是否可以通过移除岩石来实现该最小跳跃距离。如果可以，则更新答案，并尝试更大的 `mid` 值；否则，尝试更小的 `mid` 值。
>
> **`main` 函数**：
>
> - 从输入中读取参数 `L`（终点距离）、`N`（岩石数目）、`M`（最多可以移除的岩石数）以及岩石位置，最后调用 `maxMinJump` 函数计算并输出结果。
>
> 在 C++ 中，常常推荐使用常量引用（`const T&`）来传递对象，特别是当传递的是较大的数据结构（如 `vector`、`string`、`map` 等）时。这样既能提高性能，又能保证代码的清晰和安全。
>
> 
>
> **复杂度分析**：
>
> - **时间复杂度**：
>   - 二分查找的次数为 O(log L)。
>   - 每次检查是否可行的时间为 O(N)，因为我们要遍历岩石数组。
>   - 总的时间复杂度为 O(N * log L)。
> - **空间复杂度**：
>   - 主要使用一个数组 `allRocks` 来存储岩石位置和起点终点，空间复杂度为 O(N)。



## M18164: 剪绳子

Heap, http://cs101.openjudge.cn/pctbook/M18164/

小张要将一根长度为L的绳子剪成N段。准备剪的绳子的长度为L1,L2,L3...,LN，未剪的绳子长度恰好为剪后所有绳子长度的和。 

每次剪断绳子时，需要的开销是此段绳子的长度。

比如，长度为10的绳子要剪成长度为2,3,5的三段绳子。长度为10的绳子切成5和5的两段绳子时，开销为10。再将5切成长度为2和3的绳子，开销为5。因此总开销为15。


请按照目标要求将绳子剪完最小的开销时多少。

已知，1<=N <= 20000，0<=Li<= 50000

**输入**

第一行：N，将绳子剪成的段数。
第二行：准备剪成的各段绳子的长度。

**输出**

最小开销

样例输入

```
3
2 3 5
```

样例输出

```
15
```

提示

tags: greedy, huffman

来源

cs101-2017 期末机考备选



```c++
#include <iostream>
#include <queue>
#include <functional>
#include <vector>
using namespace std;

long min_Heap(long arr[], long n)
{
    priority_queue<long, vector<long>, greater<long> > minHeap;
    for (int i = 0; i < n; i++)
    {
        // if (arr[i] != 0)
            // minHeap.push(arr[i]);
        minHeap.push(arr[i]);
    }
    long totalCost = 0;
    while (minHeap.size() > 1)
    {
        long first = minHeap.top();
        minHeap.pop();
        long second = minHeap.top();
        minHeap.pop();
        totalCost += first + second;
        minHeap.push(first + second);
    }
    return totalCost;
}

int main()
{
    int n;
    long arr[20001];
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%ld", &arr[i]);
    }
    printf("%ld\n", min_Heap(arr, n));
    return 0;
}
```



## M27300: 模型整理

sortings, AI, http://cs101.openjudge.cn/pctbook/M27300/

深度学习模型（尤其是大模型）是近两年计算机学术和业界热门的研究方向。每个模型可以用 “模型名称-参数量” 命名，其中参数量的单位会使用两种：M，即百万；B，即十亿。同一个模型通常有多个不同参数的版本。

例如，Bert-110M，Bert-340M 分别代表参数量为 1.1 亿和 3.4 亿的 Bert 模型，GPT3-350M，GPT3-1.3B 和 GPT3-175B 分别代表参数量为 3.5亿，13亿和 1750 亿的 GPT3 模型。

参数量的数字部分取值在 [1, 1000) 区间（一个 8 亿参数的模型表示为 800M 而非 0.8B，10 亿参数的模型表示为 1B 而非 1000M）。

计算机专业的学生小 A 从网上收集了一份模型的列表，他需要将它们按照名称归类排序，并且同一个模型的参数量从小到大排序，生成 “模型名称: 参数量1, 参数量2, ...” 的列表。请你帮他写一个程序实现。

**输入**

第一行为一个正整数 n（n <= 1000），表示有 n 个待整理的模型。

接下来 n 行，每行一个 “模型名称-参数量” 的字符串。模型名称是字母和数字的混合。

**输出**

每行一个 “模型名称: 参数量1, 参数量2, ...” 的字符串，符号均为英文符号，模型名称按字典序排列，参数量按从小到大排序。

样例输入

```
5
GPT-1.3B
Bert-340M
GPT-350M
Bert-110M
GPT-175B
```

样例输出

```
Bert: 110M, 340M
GPT: 350M, 1.3B, 175B
```

提示

tags: string, sort

来源

2023fall zyn



```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;

class Model {
private:
    string raw;       // 原始参数量字符串，比如 "350M" 或 "1.3B"
    double value;     // 换算成 B 的数值，方便比较

public:
    string name;      // 模型名公开

    // 构造函数：接收 "模型名-参数量" 字符串
    Model(const string& fullname) {
        size_t pos = fullname.find('-');
        name = fullname.substr(0, pos);
        raw = fullname.substr(pos + 1);

        char unit = raw.back();
        double num = stod(raw.substr(0, raw.size() - 1));
        if (unit == 'M') {
            value = num / 1000.0;  // 百万 → 十亿
        } else {
            value = num;           // 已经是 B
        }
    }

    // 提供获取原始参数量字符串的方法
    string getRaw() const {
        return raw;
    }

    // 重载 < 运算符用于排序
    bool operator<(const Model& other) const {
        if (name == other.name) {
            return value < other.value;
        }
        return name < other.name;
    }
};

int main() {
    int n;
    cin >> n;
    vector<Model> models;
    models.reserve(n);

    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        models.emplace_back(s);
    }

    sort(models.begin(), models.end());

    cout << models[0].name << ": " << models[0].getRaw();
    for (int i = 1; i < n; i++) {
        if (models[i].name == models[i - 1].name) {
            cout << ", " << models[i].getRaw();
        } else {
            cout << "\n" << models[i].name << ": " << models[i].getRaw();
        }
    }
    cout << "\n";

    return 0;
}
```



> **reserve** → 提前分配内存
>
> **emplace_back** → 直接构造对象，避免不必要拷贝
>
> `struct` = 数据结构（默认 public）
>
> `class` = 面向对象（默认 private）
>
> 功能上完全等价，选择哪种主要看**语义**：
>
> - 你只是存数据 → struct 更清晰
> - 你需要封装/隐藏/继承 → class 更合适
>
> 如果用 `class`：
>
> ```c++
> class Model {
>     string name;
>     double value;
> };
> ```
>
> - 默认是 **private**
> - 你必须提供 getter 或者把成员改成 `public`：
>
> ```c++
> class Model {
> public:
>     string name;
>     double value;
> };
> ```



## 
